#pragma once

#include <string>
#include <string_view>
#include <type_traits>
#include <variant>

#include <boost/hana.hpp>
#include <range/v3/core.hpp>
#include <range/v3/view/tail.hpp>

#include <bullet/identifier.hpp>

//-------------------------------------------
// Note: this file was generated based on:
//      cd tools
//      python3 gen_tokens.py
//
// Token table is stored in tools/tokens.csv.
//-------------------------------------------

namespace lexer {
    using namespace std;
    namespace hana = boost::hana;

    namespace token {
        struct token_tag : x3::position_tagged {};

        template <typename T>
        auto operator<<(ostream& os, T) -> enable_if_t<is_base_of_v<token_tag, T>, ostream&> {
            os << "token[" << T::name << ']';
            return os;
        }

        template <typename T>
        auto operator==(T, T) -> enable_if_t<is_base_of_v<token_tag, T>, bool> {
            return true;
        }

        template <typename T>
        auto operator!=(T, T) -> enable_if_t<is_base_of_v<token_tag, T>, bool> {
            return false;
        }

        template <typename T>
        auto token_name(T) -> enable_if_t<is_base_of_v<token_tag, T>, string_view> {
            return T::name;
        }

        template <typename T>
        auto token_symbol(T) -> enable_if_t<is_base_of_v<token_tag, T>, string_view> {
            return T::token;
        }

        {{ token_class_defs }}

        constexpr auto types = hana::tuple_t<
            {{ token_type_list }}
        >;
    }

    using token_t = variant<
        {{ token_type_list_ns }},
        identifier_t
    >;

    auto operator<<(ostream& os, const token_t& t) -> ostream& {
        visit([&](auto t) { os << t; }, t);
        return os;
    }

    auto token_name(const token_t& t) -> string_view { 
        return visit([&](auto t) { return token_name(t); }, t);
    }

    auto token_symbol(const token_t& t) -> string_view { 
        return visit([&](auto t) { return token_symbol(t); }, t);
    }

    {{ tokens }}

    using token_list_t = std::vector<token_t>;

    inline auto operator==(const token_list_t& lhs, const token_list_t& rhs) -> bool {
        if (lhs.size() != rhs.size()) return false;
        const auto n = lhs.size();
        for (auto i = 0; i < n; i++)
            if (lhs[i] != rhs[i])
                return false;
        return true;
    }

    inline auto operator<<(std::ostream& os, const token_list_t& t) -> std::ostream& {
        os << '[';
        if (!ranges::empty(t)) {
            os << ranges::front(t);
            for (const auto& v: t | ranges::views::tail)
                os << ", " << v;
        }
        os << ']';
        return os;
    }
}  // namespace lexer
