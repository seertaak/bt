#pragma once

#include <string>
#include <string_view>
#include <type_traits>
#include <variant>

#include <boost/hana.hpp>
#include <range/v3/core.hpp>
#include <range/v3/view/tail.hpp>

#include <bullet/identifier.hpp>
#include <bullet/string_token.hpp>
#include <bullet/numeric_token.hpp>

//-------------------------------------------
// Note: this file was generated based on:
//      cd tools
//      python3 gen_tokens.py
//
// Token table is stored in tools/tokens.csv.
//-------------------------------------------

namespace lexer {
    using namespace std;
    namespace hana = boost::hana;

    namespace token {
        struct token_tag {};

        template <typename T>
        auto operator<<(ostream& os, T) -> enable_if_t<is_base_of_v<token_tag, T>, ostream&> {
            os << "token[" << T::name << ']';
            return os;
        }

        template <typename T>
        auto operator==(T, T) -> enable_if_t<is_base_of_v<token_tag, T>, bool> {
            return true;
        }

        template <typename T>
        auto operator!=(T, T) -> enable_if_t<is_base_of_v<token_tag, T>, bool> {
            return false;
        }

        template <typename T>
        auto token_name(T) -> enable_if_t<is_base_of_v<token_tag, T>, string_view> {
            return T::name;
        }

        template <typename T>
        auto token_symbol(T) -> enable_if_t<is_base_of_v<token_tag, T>, string_view> {
            return T::token;
        }

        {{ token_class_defs }}

        constexpr auto types = hana::tuple_t<
            {{ token_type_list }}
        >;
    }

    using token_t = variant<
        {{ token_type_list_ns }},
        identifier_t,
        string_token_t,
        literal::numeric::integral_t,
        literal::numeric::floating_point_t
    >;

    auto operator<<(ostream& os, const token_t& t) -> ostream& {
        visit([&](auto t) { os << t; }, t);
        return os;
    }

    auto token_name(const token_t& t) -> string_view { 
        return visit([&](auto t) { return token_name(t); }, t);
    }

    auto token_symbol(const token_t& t) -> string_view { 
        return visit([&](auto t) { return token_symbol(t); }, t);
    }

    {{ tokens }}

    struct location_t {
        uint32_t line;
        uint16_t first_col;
        uint16_t last_col;
    };

    inline auto operator==(const location_t& lhs, const location_t& rhs) -> bool {
        return lhs.line == rhs.line && lhs.first_col == rhs.first_col
         && lhs.last_col == rhs.last_col;
    }

    inline auto operator!=(const location_t& lhs, const location_t& rhs) -> bool {
        return !(lhs == rhs);
    }

    auto operator<<(ostream& os, const location_t& l) -> ostream& {
        os << l.line << ':' << l.first_col;
        return os;
    }

    struct source_token_t {
        token_t token;
        location_t location;

        source_token_t(const token_t& t): token(t), location{0, 0, 0} {}
        source_token_t(const token_t& t, uint32_t line, uint16_t first_col, uint16_t last_col): token(t), location{line, first_col, last_col} {}

        source_token_t() = default;
        source_token_t(const source_token_t&) = default;
        source_token_t& operator=(const source_token_t&) = default;
    };

    auto operator<<(ostream& os, const source_token_t& t) -> ostream& {
        os << t.token;
        return os;
    }

    inline auto operator==(const source_token_t& lhs, const source_token_t& rhs) -> bool {
        return lhs.token == rhs.token && lhs.location == rhs.location;
    }

    inline auto operator==(const source_token_t& lhs, const token_t& rhs) -> bool {
        return lhs.token == rhs;
    }
    inline auto operator==(const token_t& lhs, const source_token_t& rhs) -> bool {
        return rhs == lhs;
    }
    inline auto operator!=(const source_token_t& lhs, const token_t& rhs) -> bool {
        return !(lhs == rhs);
    }
    inline auto operator!=(const token_t& lhs, const source_token_t& rhs) -> bool {
        return !(lhs == rhs);
    }

    inline auto operator!=(const source_token_t& lhs, const source_token_t& rhs) -> bool {
        return !(lhs == rhs);
    }

    using source_token_list_t = std::vector<source_token_t>;
    using token_list_t = std::vector<token_t>;

    inline auto operator==(const source_token_list_t& lhs, const source_token_list_t& rhs) -> bool {
        if (lhs.size() != rhs.size()) return false;
        const auto n = lhs.size();
        for (auto i = 0; i < n; i++)
            if (lhs[i] != rhs[i]) return false;
        return true;
    }

    inline auto operator==(const source_token_list_t& lhs, const token_list_t& rhs) -> bool {
        if (lhs.size() != rhs.size()) return false;
        const auto n = lhs.size();
        for (auto i = 0; i < n; i++)
            if (lhs[i] != rhs[i]) return false;
        return true;
    }

    inline auto operator==(const token_list_t& lhs, const source_token_list_t& rhs) -> bool {
        return rhs == lhs;
    }

    inline auto operator<<(std::ostream& os, const source_token_list_t& t) -> std::ostream& {
        os << '[';
        if (!ranges::empty(t)) {
            os << ranges::front(t);
            for (const auto& v : t | ranges::views::tail) os << ", " << v;
        }
        os << ']';
        return os;
    }

    inline auto operator==(const token_list_t& lhs, const token_list_t& rhs) -> bool {
        if (lhs.size() != rhs.size()) return false;
        const auto n = lhs.size();
        for (auto i = 0; i < n; i++)
            if (lhs[i] != rhs[i]) return false;
        return true;
    }

    inline auto operator<<(std::ostream& os, const token_list_t& t) -> std::ostream& {
        os << '[';
        if (!ranges::empty(t)) {
            os << ranges::front(t);
            for (const auto& v : t | ranges::views::tail) os << ", " << v;
        }
        os << ']';
        return os;
    }
}  // namespace lexer
